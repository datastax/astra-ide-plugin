/**
* Stargate REST API reference
* The Stargate REST API provides CRUD operations on table data managed by Stargate. Keep in mind that you will need information for the server ({databaseId} and {region}) for all of these operations.
*
* The version of the OpenAPI document: 2.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package com.datastax.astra.stargate_v2.apis

import com.datastax.astra.stargate_v2.models.ColumnDefinition
import com.datastax.astra.stargate_v2.models.Error
import com.datastax.astra.stargate_v2.models.InlineResponse200
import com.datastax.astra.stargate_v2.models.InlineResponse2001
import com.datastax.astra.stargate_v2.models.InlineResponse2002
import com.datastax.astra.stargate_v2.models.InlineResponse201
import com.datastax.astra.stargate_v2.models.Keyspace
import com.datastax.astra.stargate_v2.models.Table
import com.datastax.astra.stargate_v2.models.TableAdd

import com.datastax.astra.stargate_v2.infrastructure.ApiClient
import com.datastax.astra.stargate_v2.infrastructure.ClientException
import com.datastax.astra.stargate_v2.infrastructure.ClientError
import com.datastax.astra.stargate_v2.infrastructure.ServerException
import com.datastax.astra.stargate_v2.infrastructure.ServerError
import com.datastax.astra.stargate_v2.infrastructure.MultiValueMap
import com.datastax.astra.stargate_v2.infrastructure.RequestConfig
import com.datastax.astra.stargate_v2.infrastructure.RequestMethod
import com.datastax.astra.stargate_v2.infrastructure.ResponseType
import com.datastax.astra.stargate_v2.infrastructure.Success
import com.datastax.astra.stargate_v2.infrastructure.toMultiValue

class SchemasApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("com.datastax.astra.stargate_v2.baseUrl", "https://-.apps.astra.datastax.com")
        }
    }

    /**
    * Create a column
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param columnDefinition  
    * @return InlineResponse201
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createColumn(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, columnDefinition: ColumnDefinition) : InlineResponse201 {
        val localVariableConfig = createColumnRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableId = tableId, columnDefinition = columnDefinition)

        val localVarResponse = request<InlineResponse201>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InlineResponse201
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createColumn
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param columnDefinition  
    * @return RequestConfig
    */
    fun createColumnRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, columnDefinition: ColumnDefinition) : RequestConfig {
        val localVariableBody: kotlin.Any? = columnDefinition
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables/{table-id}/columns".replace("{"+"keyspace-id"+"}", "$keyspaceId").replace("{"+"table-id"+"}", "$tableId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Create a table
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableAdd  
    * @return InlineResponse201
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTable(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableAdd: TableAdd) : InlineResponse201 {
        val localVariableConfig = createTableRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableAdd = tableAdd)

        val localVarResponse = request<InlineResponse201>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InlineResponse201
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTable
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableAdd  
    * @return RequestConfig
    */
    fun createTableRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableAdd: TableAdd) : RequestConfig {
        val localVariableBody: kotlin.Any? = tableAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables".replace("{"+"keyspace-id"+"}", "$keyspaceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Delete a column
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param columnId column name 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteColumn(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, columnId: kotlin.String) : Unit {
        val localVariableConfig = deleteColumnRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableId = tableId, columnId = columnId)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation deleteColumn
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param columnId column name 
    * @return RequestConfig
    */
    fun deleteColumnRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, columnId: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables/{table-id}/columns/{column-id}".replace("{"+"keyspace-id"+"}", "$keyspaceId").replace("{"+"table-id"+"}", "$tableId").replace("{"+"column-id"+"}", "$columnId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Delete a table
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTable(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String) : Unit {
        val localVariableConfig = deleteTableRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableId = tableId)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation deleteTable
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @return RequestConfig
    */
    fun deleteTableRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables/{table-id}".replace("{"+"keyspace-id"+"}", "$keyspaceId").replace("{"+"table-id"+"}", "$tableId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Get a column
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param columnId column name 
    * @param raw unwrap results (optional, default to false)
    * @return ColumnDefinition
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getColumn(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, columnId: kotlin.String, raw: kotlin.Boolean?) : ColumnDefinition {
        val localVariableConfig = getColumnRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableId = tableId, columnId = columnId, raw = raw)

        val localVarResponse = request<ColumnDefinition>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ColumnDefinition
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getColumn
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param columnId column name 
    * @param raw unwrap results (optional, default to false)
    * @return RequestConfig
    */
    fun getColumnRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, columnId: kotlin.String, raw: kotlin.Boolean?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (raw != null) {
                    put("raw", listOf(raw.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables/{table-id}/columns/{column-id}".replace("{"+"keyspace-id"+"}", "$keyspaceId").replace("{"+"table-id"+"}", "$tableId").replace("{"+"column-id"+"}", "$columnId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * List columns
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param raw unwrap results (optional, default to false)
    * @return InlineResponse2002
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getColumns(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, raw: kotlin.Boolean?) : InlineResponse2002 {
        val localVariableConfig = getColumnsRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableId = tableId, raw = raw)

        val localVarResponse = request<InlineResponse2002>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InlineResponse2002
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getColumns
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param raw unwrap results (optional, default to false)
    * @return RequestConfig
    */
    fun getColumnsRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, raw: kotlin.Boolean?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (raw != null) {
                    put("raw", listOf(raw.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables/{table-id}/columns".replace("{"+"keyspace-id"+"}", "$keyspaceId").replace("{"+"table-id"+"}", "$tableId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Get a keyspace using the {keyspace-id}
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param raw unwrap results (optional, default to false)
    * @return Keyspace
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getKeyspace(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, raw: kotlin.Boolean?) : Keyspace {
        val localVariableConfig = getKeyspaceRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, raw = raw)

        val localVarResponse = request<Keyspace>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Keyspace
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getKeyspace
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param raw unwrap results (optional, default to false)
    * @return RequestConfig
    */
    fun getKeyspaceRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, raw: kotlin.Boolean?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (raw != null) {
                    put("raw", listOf(raw.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}".replace("{"+"keyspace-id"+"}", "$keyspaceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Get all keyspaces
    * Retrieve all available keyspaces in the specific database.
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param raw unwrap results (optional, default to false)
    * @return InlineResponse200
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getKeyspaces(xCassandraToken: kotlin.String, raw: kotlin.Boolean?) : InlineResponse200 {
        val localVariableConfig = getKeyspacesRequestConfig(xCassandraToken = xCassandraToken, raw = raw)

        val localVarResponse = request<InlineResponse200>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InlineResponse200
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getKeyspaces
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param raw unwrap results (optional, default to false)
    * @return RequestConfig
    */
    fun getKeyspacesRequestConfig(xCassandraToken: kotlin.String, raw: kotlin.Boolean?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (raw != null) {
                    put("raw", listOf(raw.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rest/v2/schemas/keyspaces",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Get a table
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param raw unwrap results (optional, default to false)
    * @return Table
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTable(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, raw: kotlin.Boolean?) : Table {
        val localVariableConfig = getTableRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableId = tableId, raw = raw)

        val localVarResponse = request<Table>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Table
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTable
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param raw unwrap results (optional, default to false)
    * @return RequestConfig
    */
    fun getTableRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, raw: kotlin.Boolean?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (raw != null) {
                    put("raw", listOf(raw.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables/{table-id}".replace("{"+"keyspace-id"+"}", "$keyspaceId").replace("{"+"table-id"+"}", "$tableId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Get all tables
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param raw unwrap results (optional, default to false)
    * @return InlineResponse2001
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTables(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, raw: kotlin.Boolean?) : InlineResponse2001 {
        val localVariableConfig = getTablesRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, raw = raw)

        val localVarResponse = request<InlineResponse2001>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InlineResponse2001
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTables
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param raw unwrap results (optional, default to false)
    * @return RequestConfig
    */
    fun getTablesRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, raw: kotlin.Boolean?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (raw != null) {
                    put("raw", listOf(raw.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables".replace("{"+"keyspace-id"+"}", "$keyspaceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Replace a column definition
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param columnId column name 
    * @param columnDefinition  
    * @return InlineResponse201
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun replaceColumn(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, columnId: kotlin.String, columnDefinition: ColumnDefinition) : InlineResponse201 {
        val localVariableConfig = replaceColumnRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableId = tableId, columnId = columnId, columnDefinition = columnDefinition)

        val localVarResponse = request<InlineResponse201>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InlineResponse201
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation replaceColumn
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param columnId column name 
    * @param columnDefinition  
    * @return RequestConfig
    */
    fun replaceColumnRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, columnId: kotlin.String, columnDefinition: ColumnDefinition) : RequestConfig {
        val localVariableBody: kotlin.Any? = columnDefinition
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables/{table-id}/columns/{column-id}".replace("{"+"keyspace-id"+"}", "$keyspaceId").replace("{"+"table-id"+"}", "$tableId").replace("{"+"column-id"+"}", "$columnId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Replace a table definition, except for columns
    * 
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param tableAdd  
    * @return InlineResponse201
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun replaceTable(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, tableAdd: TableAdd) : InlineResponse201 {
        val localVariableConfig = replaceTableRequestConfig(xCassandraToken = xCassandraToken, keyspaceId = keyspaceId, tableId = tableId, tableAdd = tableAdd)

        val localVarResponse = request<InlineResponse201>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InlineResponse201
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation replaceTable
    *
    * @param xCassandraToken The application token for serverless databases or the token returned from the authorization endpoint for classic databases. Use this token in each request. 
    * @param keyspaceId keyspace name 
    * @param tableId table name 
    * @param tableAdd  
    * @return RequestConfig
    */
    fun replaceTableRequestConfig(xCassandraToken: kotlin.String, keyspaceId: kotlin.String, tableId: kotlin.String, tableAdd: TableAdd) : RequestConfig {
        val localVariableBody: kotlin.Any? = tableAdd
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xCassandraToken?.apply { localVariableHeaders["X-Cassandra-Token"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/rest/v2/schemas/keyspaces/{keyspace-id}/tables/{table-id}".replace("{"+"keyspace-id"+"}", "$keyspaceId").replace("{"+"table-id"+"}", "$tableId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

}
