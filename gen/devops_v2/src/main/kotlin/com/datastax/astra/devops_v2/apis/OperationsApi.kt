/**
* Astra DevOps API
* Use this REST API to perform lifecycle actions for DataStax Astra databases.</br> </br> To get started, get your application token from your Astra database. You can then create, terminate, resize, park, and unpark databases using the DevOps API. You cannot park, unpark, or resize serverless databases.  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
*
* The version of the OpenAPI document: 2.0.0
* Contact: ad-astra@datastax.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package com.datastax.astra.devops_v2.apis

import com.datastax.astra.devops_v2.models.AvailableRegionCombination
import com.datastax.astra.devops_v2.models.CapacityUnits
import com.datastax.astra.devops_v2.models.CredsURL
import com.datastax.astra.devops_v2.models.Database
import com.datastax.astra.devops_v2.models.DatabaseInfoCreate
import com.datastax.astra.devops_v2.models.Errors
import com.datastax.astra.devops_v2.models.UserPassword

import com.datastax.astra.devops_v2.infrastructure.ApiClient
import com.datastax.astra.devops_v2.infrastructure.ClientException
import com.datastax.astra.devops_v2.infrastructure.ClientError
import com.datastax.astra.devops_v2.infrastructure.ServerException
import com.datastax.astra.devops_v2.infrastructure.ServerError
import com.datastax.astra.devops_v2.infrastructure.MultiValueMap
import com.datastax.astra.devops_v2.infrastructure.RequestConfig
import com.datastax.astra.devops_v2.infrastructure.RequestMethod
import com.datastax.astra.devops_v2.infrastructure.ResponseType
import com.datastax.astra.devops_v2.infrastructure.Success
import com.datastax.astra.devops_v2.infrastructure.toMultiValue

class OperationsApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("com.datastax.astra.devops_v2.baseUrl", "https://api.astra.datastax.com")
        }
    }

    /**
    * Adds keyspace into database
    * Adds the specified keyspace to the database
    * @param databaseID String representation of the database ID 
    * @param keyspaceName Name of database keyspace 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addKeyspace(databaseID: kotlin.String, keyspaceName: kotlin.String) : Unit {
        val localVariableConfig = addKeyspaceRequestConfig(databaseID = databaseID, keyspaceName = keyspaceName)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation addKeyspace
    *
    * @param databaseID String representation of the database ID 
    * @param keyspaceName Name of database keyspace 
    * @return RequestConfig
    */
    fun addKeyspaceRequestConfig(databaseID: kotlin.String, keyspaceName: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/databases/{databaseID}/keyspaces/{keyspaceName}".replace("{"+"databaseID"+"}", "$databaseID").replace("{"+"keyspaceName"+"}", "$keyspaceName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Create a new database
    * Takes a user provided databaseInfo and returns the uuid for a new database
    * @param databaseInfoCreate Definition of new database 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createDatabase(databaseInfoCreate: DatabaseInfoCreate) : Unit {
        val localVariableConfig = createDatabaseRequestConfig(databaseInfoCreate = databaseInfoCreate)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createDatabase
    *
    * @param databaseInfoCreate Definition of new database 
    * @return RequestConfig
    */
    fun createDatabaseRequestConfig(databaseInfoCreate: DatabaseInfoCreate) : RequestConfig {
        val localVariableBody: kotlin.Any? = databaseInfoCreate
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/databases",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Obtain zip for connecting to the database
    * Returns a temporary URL to download a zip file with certificates for connecting to the database. The URL expires after five minutes.&lt;p&gt;There are two types of the secure bundle URL: &lt;ul&gt;&lt;li&gt;&lt;b&gt;Internal&lt;/b&gt; - Use with VPC peering connections to use private networking and avoid public internet for communication.&lt;/li&gt; &lt;li&gt;&lt;b&gt;External&lt;/b&gt; - Use with any connection where the public internet is sufficient for communication between the application and the Astra database with MTLS.&lt;/li&gt;&lt;/ul&gt; Both types support MTLS for communication via the driver.&lt;/p&gt;
    * @param databaseID String representation of the database ID 
    * @return CredsURL
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateSecureBundleURL(databaseID: kotlin.String) : CredsURL {
        val localVariableConfig = generateSecureBundleURLRequestConfig(databaseID = databaseID)

        val localVarResponse = request<CredsURL>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CredsURL
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation generateSecureBundleURL
    *
    * @param databaseID String representation of the database ID 
    * @return RequestConfig
    */
    fun generateSecureBundleURLRequestConfig(databaseID: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/databases/{databaseID}/secureBundleURL".replace("{"+"databaseID"+"}", "$databaseID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Finds database by ID
    * Returns specified database
    * @param databaseID String representation of the database ID 
    * @return Database
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDatabase(databaseID: kotlin.String) : Database {
        val localVariableConfig = getDatabaseRequestConfig(databaseID = databaseID)

        val localVarResponse = request<Database>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Database
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getDatabase
    *
    * @param databaseID String representation of the database ID 
    * @return RequestConfig
    */
    fun getDatabaseRequestConfig(databaseID: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/databases/{databaseID}".replace("{"+"databaseID"+"}", "$databaseID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Returns supported regions and availability for a given user and organization
    * Returns all supported tier, cloud, region, count, and capacitity combinations
    * @return kotlin.collections.List<AvailableRegionCombination>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listAvailableRegions() : kotlin.collections.List<AvailableRegionCombination> {
        val localVariableConfig = listAvailableRegionsRequestConfig()

        val localVarResponse = request<kotlin.collections.List<AvailableRegionCombination>>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AvailableRegionCombination>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listAvailableRegions
    *
    * @return RequestConfig
    */
    fun listAvailableRegionsRequestConfig() : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/availableRegions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Returns a list of databases
    * Get a list of databases visible to the user
    * @param include Allows filtering so that databases in listed states are returned (optional, default to nonterminated)
    * @param provider Allows filtering so that databases from a given provider are returned (optional, default to ALL)
    * @param startingAfter Optional parameter for pagination purposes. Used as this value for starting retrieving a specific page of results (optional)
    * @param limit Optional parameter for pagination purposes. Specify the number of items for one page of data (optional, default to 25)
    * @return kotlin.collections.List<Database>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDatabases(include: kotlin.String?, provider: kotlin.String?, startingAfter: kotlin.String?, limit: kotlin.Int?) : kotlin.collections.List<Database> {
        val localVariableConfig = listDatabasesRequestConfig(include = include, provider = provider, startingAfter = startingAfter, limit = limit)

        val localVarResponse = request<kotlin.collections.List<Database>>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Database>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listDatabases
    *
    * @param include Allows filtering so that databases in listed states are returned (optional, default to nonterminated)
    * @param provider Allows filtering so that databases from a given provider are returned (optional, default to ALL)
    * @param startingAfter Optional parameter for pagination purposes. Used as this value for starting retrieving a specific page of results (optional)
    * @param limit Optional parameter for pagination purposes. Specify the number of items for one page of data (optional, default to 25)
    * @return RequestConfig
    */
    fun listDatabasesRequestConfig(include: kotlin.String?, provider: kotlin.String?, startingAfter: kotlin.String?, limit: kotlin.Int?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
                if (provider != null) {
                    put("provider", listOf(provider.toString()))
                }
                if (startingAfter != null) {
                    put("starting_after", listOf(startingAfter.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/databases",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Parks a database
    * Parks a database
    * @param databaseID String representation of the database ID 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parkDatabase(databaseID: kotlin.String) : Unit {
        val localVariableConfig = parkDatabaseRequestConfig(databaseID = databaseID)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation parkDatabase
    *
    * @param databaseID String representation of the database ID 
    * @return RequestConfig
    */
    fun parkDatabaseRequestConfig(databaseID: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/databases/{databaseID}/park".replace("{"+"databaseID"+"}", "$databaseID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Resets Password
    * Sets a database password to the one specified in POST body
    * @param databaseID String representation of the database ID 
    * @param userPassword Map containing username and password. The specified password will be updated for the specified database user 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun resetPassword(databaseID: kotlin.String, userPassword: UserPassword) : Unit {
        val localVariableConfig = resetPasswordRequestConfig(databaseID = databaseID, userPassword = userPassword)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation resetPassword
    *
    * @param databaseID String representation of the database ID 
    * @param userPassword Map containing username and password. The specified password will be updated for the specified database user 
    * @return RequestConfig
    */
    fun resetPasswordRequestConfig(databaseID: kotlin.String, userPassword: UserPassword) : RequestConfig {
        val localVariableBody: kotlin.Any? = userPassword
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/databases/{databaseID}/resetPassword".replace("{"+"databaseID"+"}", "$databaseID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Resizes a database
    * Resizes a database. Total number of capacity units desired should be specified. Reducing a size of a database is not supported at this time.
    * @param databaseID String representation of the database ID 
    * @param capacityUnits Map containing capacityUnits key with a value greater than the current number of capacity units (max increment of 3 additional capacity units) 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun resizeDatabase(databaseID: kotlin.String, capacityUnits: CapacityUnits) : Unit {
        val localVariableConfig = resizeDatabaseRequestConfig(databaseID = databaseID, capacityUnits = capacityUnits)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation resizeDatabase
    *
    * @param databaseID String representation of the database ID 
    * @param capacityUnits Map containing capacityUnits key with a value greater than the current number of capacity units (max increment of 3 additional capacity units) 
    * @return RequestConfig
    */
    fun resizeDatabaseRequestConfig(databaseID: kotlin.String, capacityUnits: CapacityUnits) : RequestConfig {
        val localVariableBody: kotlin.Any? = capacityUnits
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/databases/{databaseID}/resize".replace("{"+"databaseID"+"}", "$databaseID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Terminates a database
    * Terminates a database
    * @param databaseID String representation of the database ID 
    * @param preparedStateOnly For internal use only.  Used to safely terminate prepared databases. (optional, default to false)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun terminateDatabase(databaseID: kotlin.String, preparedStateOnly: kotlin.Boolean?) : Unit {
        val localVariableConfig = terminateDatabaseRequestConfig(databaseID = databaseID, preparedStateOnly = preparedStateOnly)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation terminateDatabase
    *
    * @param databaseID String representation of the database ID 
    * @param preparedStateOnly For internal use only.  Used to safely terminate prepared databases. (optional, default to false)
    * @return RequestConfig
    */
    fun terminateDatabaseRequestConfig(databaseID: kotlin.String, preparedStateOnly: kotlin.Boolean?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (preparedStateOnly != null) {
                    put("preparedStateOnly", listOf(preparedStateOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/databases/{databaseID}/terminate".replace("{"+"databaseID"+"}", "$databaseID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Unparks a database
    * Unparks a database
    * @param databaseID String representation of the database ID 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun unparkDatabase(databaseID: kotlin.String) : Unit {
        val localVariableConfig = unparkDatabaseRequestConfig(databaseID = databaseID)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation unparkDatabase
    *
    * @param databaseID String representation of the database ID 
    * @return RequestConfig
    */
    fun unparkDatabaseRequestConfig(databaseID: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/databases/{databaseID}/unpark".replace("{"+"databaseID"+"}", "$databaseID"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

}
